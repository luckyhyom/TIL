# 모듈의 필요성

- 코드베이스를 나누어 여러 파일로 분할하여 관리할 수 있다.
- 다른 프로젝트에 코드를 재사용 할 수 있다.
- 모듈이 작으면 종속성을 쉽게 관리할 수 있다.
- 은닉성을 제공합니다. (내부 구현을 숨기고 인터페이스를 제공)

Node.js는 운영체제의 파일시스템에 직접ㅂ적으로 접근하는 Javascript를 위한 서러 런타임으로 구상되었다. HTML의 스크립트나 URL을 통한 리소스 접근에 의존하지 않고 오직 로컬 파일 시스템의 js 파일들에만 의존하는 것이다.

CommonJS의 탄생 이유는 브라우저가 아닌 환경에서 js 모듈 시스템을 제공할수 있도록 하기 위해서이다.

ESM은 브라우저와 서버와의 모듈관리 차이점을 연결하기 위해 노력했다.

### 노출식 모듈 패턴

```
const myModule = () => {
    const privateData = {};
    const privateArr = [];
    const export =  {
        getData: () => privateData,
        getArr: () => privateArr,
    };
    return export;
};
```

즉시실행을 하지 않으면.. 매번 실행할때마다 초기화가 된다. 왜 함수여야하나? -> 함수의 지역변수에 접근할 수 없는 현상을 활용해야해서

<b>이 패턴을 기반으로 하는 아이디어가 CommonJS 모듈 시스템에서 사용된다.</b>

### CommonJS 모듈

- require는 로컬 파일 시스템으로부터 모듈을 임포트하게 해줍니다.
- export와 module.exports는 특별한 변수로서 현재 모듈에서 공개될 기능들을 내보내기 위해서 사용됩니다.

### 비동기 임포트

- 커맨드 라인의 인자를 받아 동적으로 import될 파일의 경로를 정할 수 있다.

### ESM

- 순환 참조시 서로에 대한 완전한 내용을 갖는다.
- 인터프리터는 모든 모듈의 그래프를 만들어낸다.

  - 진입점에서부터 필요한 모든 코드가 탐색되고 평가 될 때 까지 import 구문을 재귀적인 깊이 우선 탐색으로 찾는다.

  1. 생성 (모든 import 구문을 찾고 재귀적으로 각 파일로부터 모든 모듈의 내용을 적재한다.)
  2. 인스턴스화 (익스포트된 모든 개체들에 대해 명명된 참조를 메모리에 유지합니다. 또한 모든 import및 export문에 대한 참조가 생성되어 이들 간의 종속성 관계 (linking)를 추적합니다. 이 단계에서 어떠한 js코드도 실행되지 않습니다.)
  3. 평가 (Node.js는 마지막으로 코드를 실행하여 이전에 ㅇ니스턴스화된 모든 개체가 실제 값을 얻을 수 있도록 합니다.)

- 객체의 특성을 이용하여 모듈의 기능을 목킹할수있다.

- 기본적으로 use strict에서 실행된다.
- **dirname **filename이 없다. 대신 import.meta.url로 현재 파일에 대한 정보를 알 수 있다.
- JSON파일을 직접적으로 가져오지 못한다. createRequire유틸을 활용해야한다.
